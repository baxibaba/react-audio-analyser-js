{"version":3,"sources":["../../src/component/AudioAnalyser/audioConvertWav.js"],"names":["audioBufferToWav","buffer","opt","numChannels","numberOfChannels","sampleRate","format","float32","bitDepth","result","interleave","getChannelData","encodeWAV","samples","bytesPerSample","blockAlign","ArrayBuffer","length","view","DataView","writeString","setUint32","setUint16","floatTo16BitPCM","writeFloat32","inputL","inputR","Float32Array","index","inputIndex","output","offset","input","i","setFloat32","s","Math","max","min","setInt16","string","setUint8","charCodeAt"],"mappings":"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","file":"audioConvertWav.js","sourcesContent":["/**\r\n * Created by j_bleach on 2018/8/25.\r\n */\r\nfunction audioBufferToWav(buffer, opt = {}) {\r\n    let numChannels = buffer.numberOfChannels\r\n    let sampleRate = opt.sampleRate || buffer.sampleRate\r\n    let format = opt.float32 ? 3 : 1\r\n    let bitDepth = format === 3 ? 32 : 16\r\n    let result\r\n    if (numChannels === 2) {\r\n        result = interleave(buffer.getChannelData(0), buffer.getChannelData(1))\r\n    } else {\r\n        result = buffer.getChannelData(0)\r\n    }\r\n\r\n    return encodeWAV(result, format, sampleRate, numChannels, bitDepth)\r\n}\r\n\r\nfunction encodeWAV(samples, format, sampleRate, numChannels, bitDepth) {\r\n    let bytesPerSample = bitDepth / 8\r\n    let blockAlign = numChannels * bytesPerSample\r\n\r\n    let buffer = new ArrayBuffer(44 + samples.length * bytesPerSample)\r\n    let view = new DataView(buffer)\r\n\r\n    /* RIFF identifier */\r\n    writeString(view, 0, \"RIFF\")\r\n    /* RIFF chunk length */\r\n    view.setUint32(4, 36 + samples.length * bytesPerSample, true)\r\n    /* RIFF type */\r\n    writeString(view, 8, \"WAVE\")\r\n    /* format chunk identifier */\r\n    writeString(view, 12, \"fmt \")\r\n    /* format chunk length */\r\n    view.setUint32(16, 16, true)\r\n    /* sample format (raw) */\r\n    view.setUint16(20, format, true)\r\n    /* channel count */\r\n    view.setUint16(22, numChannels, true)\r\n    /* sample rate */\r\n    view.setUint32(24, sampleRate, true)\r\n    /* byte rate (sample rate * block align) */\r\n    view.setUint32(28, sampleRate * blockAlign, true)\r\n    /* block align (channel count * bytes per sample) */\r\n    view.setUint16(32, blockAlign, true)\r\n    /* bits per sample */\r\n    view.setUint16(34, bitDepth, true)\r\n    /* data chunk identifier */\r\n    writeString(view, 36, \"data\")\r\n    /* data chunk length */\r\n    view.setUint32(40, samples.length * bytesPerSample, true)\r\n    if (format === 1) { // Raw PCM\r\n        floatTo16BitPCM(view, 44, samples)\r\n    } else {\r\n        writeFloat32(view, 44, samples)\r\n    }\r\n\r\n    return buffer\r\n}\r\n\r\nfunction interleave(inputL, inputR) {\r\n    let length = inputL.length + inputR.length\r\n    let result = new Float32Array(length)\r\n\r\n    let index = 0\r\n    let inputIndex = 0\r\n\r\n    while (index < length) {\r\n        result[index++] = inputL[inputIndex]\r\n        result[index++] = inputR[inputIndex]\r\n        inputIndex++\r\n    }\r\n    return result\r\n}\r\n\r\nfunction writeFloat32(output, offset, input) {\r\n    for (let i = 0; i < input.length; i++, offset += 4) {\r\n        output.setFloat32(offset, input[i], true)\r\n    }\r\n}\r\n\r\nfunction floatTo16BitPCM(output, offset, input) {\r\n    for (let i = 0; i < input.length; i++, offset += 2) {\r\n        let s = Math.max(-1, Math.min(1, input[i]))\r\n        output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true)\r\n    }\r\n}\r\n\r\nfunction writeString(view, offset, string) {\r\n    for (let i = 0; i < string.length; i++) {\r\n        view.setUint8(offset + i, string.charCodeAt(i))\r\n    }\r\n}\r\n\r\nexport default audioBufferToWav"]}